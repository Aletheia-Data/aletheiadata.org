{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport * as ElasticAppSearch from \"@elastic/app-search-javascript\";\nimport { version } from \"../package.json\";\nimport { adaptResponse } from \"./responseAdapter\";\nimport { adaptRequest } from \"./requestAdapters\";\nimport buildResponseAdapterOptions from \"./buildResponseAdapterOptions\"; // The API will error out if empty facets or filters objects\n// are sent.\n\nfunction removeEmptyFacetsAndFilters(options) {\n  var facets = options.facets,\n      filters = options.filters,\n      rest = _objectWithoutProperties(options, [\"facets\", \"filters\"]);\n\n  return _objectSpread({}, facets && Object.entries(facets).length > 0 && {\n    facets: facets\n  }, {}, filters && Object.entries(filters).length > 0 && {\n    filters: filters\n  }, {}, rest);\n}\n\nvar AppSearchAPIConnector =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @callback next\n   * @param {Object} updatedQueryOptions The options to send to the API\n   */\n\n  /**\n   * @callback hook\n   * @param {Object} queryOptions The options that are about to be sent to the API\n   * @param {next} next The options that are about to be sent to the API\n   */\n\n  /**\n   * @typedef Options\n   * @param {string} searchKey Credential found in your App Search Dashboard\n   * @param {string} engineName Engine to query, found in your App Search Dashboard\n   * @param {string} hostIdentifier Credential found in your App Search Dashboard\n   *  Useful when proxying the Swiftype API or developing against a local API server.\n   * @param {hook} beforeSearchCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to the\n   *   API in a query on an \"onSearch\" event.\n   * @param {hook} beforeAutocompleteResultsCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to the\n   *   API in a \"results\" query on an \"onAutocomplete\" event.\n   * @param {hook} beforeAutocompleteSuggestionsCall=(queryOptions,next)=>next(queryOptions) A hook to amend query options before the request is sent to\n   * the API in a \"suggestions\" query on an \"onAutocomplete\" event.\n   * @param {string} endpointBase=\"\" Overrides the base of the Swiftype API endpoint completely.\n   */\n\n  /**\n   * @param {Options} options\n   */\n  function AppSearchAPIConnector(_ref) {\n    var searchKey = _ref.searchKey,\n        engineName = _ref.engineName,\n        hostIdentifier = _ref.hostIdentifier,\n        _ref$beforeSearchCall = _ref.beforeSearchCall,\n        beforeSearchCall = _ref$beforeSearchCall === void 0 ? function (queryOptions, next) {\n      return next(queryOptions);\n    } : _ref$beforeSearchCall,\n        _ref$beforeAutocomple = _ref.beforeAutocompleteResultsCall,\n        beforeAutocompleteResultsCall = _ref$beforeAutocomple === void 0 ? function (queryOptions, next) {\n      return next(queryOptions);\n    } : _ref$beforeAutocomple,\n        _ref$beforeAutocomple2 = _ref.beforeAutocompleteSuggestionsCall,\n        beforeAutocompleteSuggestionsCall = _ref$beforeAutocomple2 === void 0 ? function (queryOptions, next) {\n      return next(queryOptions);\n    } : _ref$beforeAutocomple2,\n        _ref$endpointBase = _ref.endpointBase,\n        endpointBase = _ref$endpointBase === void 0 ? \"\" : _ref$endpointBase;\n\n    _classCallCheck(this, AppSearchAPIConnector);\n\n    if (!engineName || !(hostIdentifier || endpointBase) || !searchKey) {\n      throw Error(\"hostIdentifier or endpointBase, engineName, and searchKey are required\");\n    }\n\n    this.client = ElasticAppSearch.createClient(_objectSpread({}, endpointBase && {\n      endpointBase: endpointBase\n    }, {}, hostIdentifier && {\n      hostIdentifier: hostIdentifier\n    }, {\n      apiKey: searchKey,\n      engineName: engineName,\n      additionalHeaders: {\n        \"x-swiftype-integration\": \"search-ui\",\n        \"x-swiftype-integration-version\": version\n      }\n    }));\n    this.beforeSearchCall = beforeSearchCall;\n    this.beforeAutocompleteResultsCall = beforeAutocompleteResultsCall;\n    this.beforeAutocompleteSuggestionsCall = beforeAutocompleteSuggestionsCall;\n  }\n\n  _createClass(AppSearchAPIConnector, [{\n    key: \"onResultClick\",\n    value: function onResultClick(_ref2) {\n      var query = _ref2.query,\n          documentId = _ref2.documentId,\n          requestId = _ref2.requestId,\n          _ref2$tags = _ref2.tags,\n          tags = _ref2$tags === void 0 ? [] : _ref2$tags;\n      tags = tags.concat(\"results\");\n      return this.client.click({\n        query: query,\n        documentId: documentId,\n        requestId: requestId,\n        tags: tags\n      });\n    }\n  }, {\n    key: \"onAutocompleteResultClick\",\n    value: function onAutocompleteResultClick(_ref3) {\n      var query = _ref3.query,\n          documentId = _ref3.documentId,\n          requestId = _ref3.requestId,\n          _ref3$tags = _ref3.tags,\n          tags = _ref3$tags === void 0 ? [] : _ref3$tags;\n      tags = tags.concat(\"autocomplete\");\n      return this.client.click({\n        query: query,\n        documentId: documentId,\n        requestId: requestId,\n        tags: tags\n      });\n    }\n  }, {\n    key: \"onSearch\",\n    value: function () {\n      var _onSearch = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(state, queryConfig) {\n        var _this = this;\n\n        var current, filters, resultsPerPage, sortDirection, sortField, restOfQueryConfig, _adaptRequest, query, optionsFromState, withQueryConfigOptions, options;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                current = queryConfig.current, filters = queryConfig.filters, resultsPerPage = queryConfig.resultsPerPage, sortDirection = queryConfig.sortDirection, sortField = queryConfig.sortField, restOfQueryConfig = _objectWithoutProperties(queryConfig, [\"current\", \"filters\", \"resultsPerPage\", \"sortDirection\", \"sortField\"]);\n                _adaptRequest = adaptRequest(_objectSpread({}, state, {}, current !== undefined && {\n                  current: current\n                }, {}, filters !== undefined && {\n                  filters: filters\n                }, {}, resultsPerPage !== undefined && {\n                  resultsPerPage: resultsPerPage\n                }, {}, sortDirection !== undefined && {\n                  sortDirection: sortDirection\n                }, {}, sortField !== undefined && {\n                  sortField: sortField\n                })), query = _adaptRequest.query, optionsFromState = _objectWithoutProperties(_adaptRequest, [\"query\"]);\n                withQueryConfigOptions = _objectSpread({}, restOfQueryConfig, {}, optionsFromState);\n                options = _objectSpread({}, removeEmptyFacetsAndFilters(withQueryConfigOptions));\n                return _context2.abrupt(\"return\", this.beforeSearchCall(options,\n                /*#__PURE__*/\n                function () {\n                  var _ref4 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee(newOptions) {\n                    var response;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return _this.client.search(query, newOptions);\n\n                          case 2:\n                            response = _context.sent;\n                            return _context.abrupt(\"return\", adaptResponse(response, buildResponseAdapterOptions(queryConfig)));\n\n                          case 4:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x3) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }()));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function onSearch(_x, _x2) {\n        return _onSearch.apply(this, arguments);\n      }\n\n      return onSearch;\n    }()\n  }, {\n    key: \"onAutocomplete\",\n    value: function () {\n      var _onAutocomplete = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(_ref5, queryConfig) {\n        var _this2 = this;\n\n        var searchTerm, autocompletedState, promises, _queryConfig$results, current, filters, resultsPerPage, sortDirection, sortField, restOfQueryConfig, _adaptRequest2, query, optionsFromState, withQueryConfigOptions, options, _options;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                searchTerm = _ref5.searchTerm;\n                autocompletedState = {};\n                promises = [];\n\n                if (queryConfig.results) {\n                  _queryConfig$results = queryConfig.results, current = _queryConfig$results.current, filters = _queryConfig$results.filters, resultsPerPage = _queryConfig$results.resultsPerPage, sortDirection = _queryConfig$results.sortDirection, sortField = _queryConfig$results.sortField, restOfQueryConfig = _objectWithoutProperties(_queryConfig$results, [\"current\", \"filters\", \"resultsPerPage\", \"sortDirection\", \"sortField\"]);\n                  _adaptRequest2 = adaptRequest({\n                    current: current,\n                    searchTerm: searchTerm,\n                    filters: filters,\n                    resultsPerPage: resultsPerPage,\n                    sortDirection: sortDirection,\n                    sortField: sortField\n                  }), query = _adaptRequest2.query, optionsFromState = _objectWithoutProperties(_adaptRequest2, [\"query\"]);\n                  withQueryConfigOptions = _objectSpread({}, restOfQueryConfig, {}, optionsFromState);\n                  options = removeEmptyFacetsAndFilters(withQueryConfigOptions);\n                  promises.push(this.beforeAutocompleteResultsCall(options, function (newOptions) {\n                    return _this2.client.search(query, newOptions).then(function (response) {\n                      autocompletedState.autocompletedResults = adaptResponse(response).results;\n                      autocompletedState.autocompletedResultsRequestId = response.info.meta.request_id;\n                    });\n                  }));\n                }\n\n                if (queryConfig.suggestions) {\n                  _options = queryConfig.suggestions;\n                  promises.push(this.beforeAutocompleteSuggestionsCall(_options, function (newOptions) {\n                    return _this2.client.querySuggestion(searchTerm, newOptions).then(function (response) {\n                      autocompletedState.autocompletedSuggestions = response.results;\n                      autocompletedState.autocompletedSuggestionsRequestId = response.meta.request_id;\n                    });\n                  }));\n                }\n\n                _context3.next = 7;\n                return Promise.all(promises);\n\n              case 7:\n                return _context3.abrupt(\"return\", autocompletedState);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function onAutocomplete(_x4, _x5) {\n        return _onAutocomplete.apply(this, arguments);\n      }\n\n      return onAutocomplete;\n    }()\n  }]);\n\n  return AppSearchAPIConnector;\n}();\n\nexport default AppSearchAPIConnector;","map":null,"metadata":{},"sourceType":"module"}