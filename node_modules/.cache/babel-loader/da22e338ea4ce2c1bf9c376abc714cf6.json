{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { createBrowserHistory as createHistory } from \"history\";\nimport queryString from \"./queryString\";\n\nfunction isNumericString(num) {\n  return !isNaN(num);\n}\n\nfunction toSingleValue(val) {\n  return Array.isArray(val) ? val[val.length - 1] : val;\n}\n\nfunction toSingleValueInteger(num) {\n  return toInteger(toSingleValue(num));\n}\n\nfunction toInteger(num) {\n  if (!isNumericString(num)) return;\n  return parseInt(num, 10);\n}\n\nfunction parseFiltersFromQueryParams(queryParams) {\n  return queryParams.filters;\n}\n\nfunction parseCurrentFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.current);\n}\n\nfunction parseSearchTermFromQueryParams(queryParams) {\n  return toSingleValue(queryParams.q);\n}\n\nfunction parseSortFromQueryParams(queryParams) {\n  var sortField = toSingleValue(queryParams[\"sort-field\"]);\n  var sortDirection = toSingleValue(queryParams[\"sort-direction\"]);\n  if (sortField) return [sortField, sortDirection];\n  return [];\n}\n\nfunction parseSizeFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.size);\n}\n\nfunction paramsToState(queryParams) {\n  var state = {\n    current: parseCurrentFromQueryParams(queryParams),\n    filters: parseFiltersFromQueryParams(queryParams),\n    searchTerm: parseSearchTermFromQueryParams(queryParams),\n    resultsPerPage: parseSizeFromQueryParams(queryParams),\n    sortField: parseSortFromQueryParams(queryParams)[0],\n    sortDirection: parseSortFromQueryParams(queryParams)[1]\n  };\n  return Object.keys(state).reduce(function (acc, key) {\n    var value = state[key];\n    if (value) acc[key] = value;\n    return acc;\n  }, {});\n}\n\nfunction stateToParams(_ref) {\n  var searchTerm = _ref.searchTerm,\n      current = _ref.current,\n      filters = _ref.filters,\n      resultsPerPage = _ref.resultsPerPage,\n      sortDirection = _ref.sortDirection,\n      sortField = _ref.sortField;\n  var params = {};\n  if (current > 1) params.current = current;\n  if (searchTerm) params.q = searchTerm;\n  if (resultsPerPage) params.size = resultsPerPage;\n\n  if (filters && filters.length > 0) {\n    params[\"filters\"] = filters;\n  }\n\n  if (sortField) {\n    params[\"sort-field\"] = sortField;\n    params[\"sort-direction\"] = sortDirection;\n  }\n\n  return params;\n}\n\nfunction stateToQueryString(state) {\n  return queryString.stringify(stateToParams(state));\n}\n/**\n * The URL Manager is responsible for synchronizing state between\n * SearchDriver and the URL. There are 3 main cases we handle when\n * synchronizing:\n *\n * 1. When the app loads, SearchDriver will need to\n * read the current state from the URL, in order to perform the search\n * expressed by the query string. `getStateFromURL` is used for this case.\n *\n * 2. When the URL changes as a result of `pushState` or `replaceState`,\n * SearchDriver will need to be notified and given the updated state, so that\n * it can re-run the current search. `onURLStateChange` is used for this case.\n *\n * 3. When state changes internally in the SearchDriver, as a result of an\n * Action, it will need to notify the URLManager of the change. `pushStateToURL`\n * is used for this case.\n */\n\n\nvar URLManager =\n/*#__PURE__*/\nfunction () {\n  function URLManager() {\n    _classCallCheck(this, URLManager);\n\n    this.history = createHistory();\n    this.lastPushSearchString = \"\";\n  }\n  /**\n   * Parse the current URL into application state\n   *\n   * @return {Object} - The parsed state object\n   */\n\n\n  _createClass(URLManager, [{\n    key: \"getStateFromURL\",\n    value: function getStateFromURL() {\n      return paramsToState(queryString.parse(this.history.location.search));\n    }\n    /**\n     * Push the current state of the application to the URL\n     *\n     * @param {Object} state - The entire current state from the SearchDriver\n     * @param {boolean} options\n     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n     * rather than 'push' to avoid adding a new history entry\n     */\n\n  }, {\n    key: \"pushStateToURL\",\n    value: function pushStateToURL(state) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$replaceUrl = _ref2.replaceUrl,\n          replaceUrl = _ref2$replaceUrl === void 0 ? false : _ref2$replaceUrl;\n\n      var searchString = stateToQueryString(state);\n      this.lastPushSearchString = searchString;\n      var navigationFunction = replaceUrl ? this.history.replace : this.history.push;\n      navigationFunction({\n        search: \"?\".concat(searchString)\n      });\n    }\n    /**\n     * Add an event handler to be executed whenever state is pushed to the URL\n     *\n     * @callback requestCallback\n     * @param {Object} state - Updated application state parsed from the new URL\n     *\n     * @param {requestCallback} callback\n     */\n\n  }, {\n    key: \"onURLStateChange\",\n    value: function onURLStateChange(callback) {\n      var _this = this;\n\n      this.unlisten = this.history.listen(function (location) {\n        // If this URL is updated as a result of a pushState request, we don't\n        // want to notify that the URL changed.\n        if (\"?\".concat(_this.lastPushSearchString) === location.search) return; // Once we've decided to return based on lastPushSearchString, reset\n        // it so that we don't break back / forward button.\n\n        _this.lastPushSearchString = \"\";\n        callback(paramsToState(queryString.parse(location.search)));\n      });\n    }\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.unlisten();\n    }\n  }]);\n\n  return URLManager;\n}();\n\nexport { URLManager as default };","map":null,"metadata":{},"sourceType":"module"}