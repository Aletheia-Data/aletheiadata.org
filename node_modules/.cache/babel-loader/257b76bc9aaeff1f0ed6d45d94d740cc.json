{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport URLManager from \"./URLManager\";\nimport RequestSequencer from \"./RequestSequencer\";\nimport DebounceManager from \"./DebounceManager\";\nimport * as actions from \"./actions\";\nimport Events from \"./Events\";\nimport * as a11y from \"./A11yNotifications\";\n\nfunction filterSearchParameters(_ref) {\n  var current = _ref.current,\n      filters = _ref.filters,\n      resultsPerPage = _ref.resultsPerPage,\n      searchTerm = _ref.searchTerm,\n      sortDirection = _ref.sortDirection,\n      sortField = _ref.sortField;\n  return {\n    current: current,\n    filters: filters,\n    resultsPerPage: resultsPerPage,\n    searchTerm: searchTerm,\n    sortDirection: sortDirection,\n    sortField: sortField\n  };\n}\n\nexport var DEFAULT_STATE = {\n  // Search Parameters -- This is state that represents the input state.\n  current: 1,\n  filters: [],\n  resultsPerPage: 20,\n  searchTerm: \"\",\n  sortDirection: \"\",\n  sortField: \"\",\n  // Result State -- This state represents state that is updated automatically\n  // as the result of changing input state.\n  autocompletedResults: [],\n  autocompletedResultsRequestId: \"\",\n  autocompletedSuggestions: {},\n  autocompletedSuggestionsRequestId: \"\",\n  error: \"\",\n  isLoading: false,\n  facets: {},\n  requestId: \"\",\n  results: [],\n  resultSearchTerm: \"\",\n  totalPages: 0,\n  totalResults: 0,\n  pagingStart: 0,\n  pagingEnd: 0,\n  wasSearched: false\n};\n\nfunction removeConditionalFacets() {\n  var facets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var conditionalFacets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return Object.entries(facets).reduce(function (acc, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        facetKey = _ref3[0],\n        facet = _ref3[1];\n\n    if (conditionalFacets[facetKey] && typeof conditionalFacets[facetKey] === \"function\" && !conditionalFacets[facetKey]({\n      filters: filters\n    })) {\n      return acc;\n    }\n\n    acc[facetKey] = facet;\n    return acc;\n  }, {});\n}\n/*\n * The Driver is a framework agnostic search state manager that is capable\n * syncing state to the url.\n */\n\n\nvar SearchDriver =\n/*#__PURE__*/\nfunction () {\n  function SearchDriver(_ref4) {\n    var _this = this;\n\n    var apiConnector = _ref4.apiConnector,\n        _ref4$autocompleteQue = _ref4.autocompleteQuery,\n        autocompleteQuery = _ref4$autocompleteQue === void 0 ? {} : _ref4$autocompleteQue,\n        debug = _ref4.debug,\n        initialState = _ref4.initialState,\n        onSearch = _ref4.onSearch,\n        onAutocomplete = _ref4.onAutocomplete,\n        onResultClick = _ref4.onResultClick,\n        onAutocompleteResultClick = _ref4.onAutocompleteResultClick,\n        _ref4$searchQuery = _ref4.searchQuery,\n        searchQuery = _ref4$searchQuery === void 0 ? {} : _ref4$searchQuery,\n        _ref4$trackUrlState = _ref4.trackUrlState,\n        trackUrlState = _ref4$trackUrlState === void 0 ? true : _ref4$trackUrlState,\n        _ref4$urlPushDebounce = _ref4.urlPushDebounceLength,\n        urlPushDebounceLength = _ref4$urlPushDebounce === void 0 ? 500 : _ref4$urlPushDebounce,\n        _ref4$hasA11yNotifica = _ref4.hasA11yNotifications,\n        hasA11yNotifications = _ref4$hasA11yNotifica === void 0 ? false : _ref4$hasA11yNotifica,\n        _ref4$a11yNotificatio = _ref4.a11yNotificationMessages,\n        a11yNotificationMessages = _ref4$a11yNotificatio === void 0 ? {} : _ref4$a11yNotificatio,\n        _ref4$alwaysSearchOnI = _ref4.alwaysSearchOnInitialLoad,\n        alwaysSearchOnInitialLoad = _ref4$alwaysSearchOnI === void 0 ? false : _ref4$alwaysSearchOnI;\n\n    _classCallCheck(this, SearchDriver);\n\n    _defineProperty(this, \"state\", DEFAULT_STATE);\n\n    _defineProperty(this, \"_updateAutocomplete\", function (searchTerm) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          autocompleteResults = _ref5.autocompleteResults,\n          autocompleteSuggestions = _ref5.autocompleteSuggestions;\n\n      var requestId = _this.autocompleteRequestSequencer.next();\n\n      var queryConfig = _objectSpread({}, autocompleteResults && {\n        results: _this.autocompleteQuery.results || {}\n      }, {}, autocompleteSuggestions && {\n        suggestions: _this.autocompleteQuery.suggestions || {}\n      });\n\n      return _this.events.autocomplete({\n        searchTerm: searchTerm\n      }, queryConfig).then(function (autocompleted) {\n        if (_this.autocompleteRequestSequencer.isOldRequest(requestId)) return;\n\n        _this.autocompleteRequestSequencer.completed(requestId);\n\n        _this._setState(autocompleted);\n      });\n    });\n\n    _defineProperty(this, \"_updateSearchResults\", function (searchParameters) {\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref6$skipPushToUrl = _ref6.skipPushToUrl,\n          skipPushToUrl = _ref6$skipPushToUrl === void 0 ? false : _ref6$skipPushToUrl,\n          _ref6$replaceUrl = _ref6.replaceUrl,\n          replaceUrl = _ref6$replaceUrl === void 0 ? false : _ref6$replaceUrl;\n\n      var _this$state$searchPar = _objectSpread({}, _this.state, {}, searchParameters),\n          current = _this$state$searchPar.current,\n          filters = _this$state$searchPar.filters,\n          resultsPerPage = _this$state$searchPar.resultsPerPage,\n          searchTerm = _this$state$searchPar.searchTerm,\n          sortDirection = _this$state$searchPar.sortDirection,\n          sortField = _this$state$searchPar.sortField; // State updates should always be applied in the order that they are made. This function, _updateSearchResults,\n      // makes state updates.\n      // In the case where a call to \"_updateSearchResults\" was made and delayed for X amount of time using\n      // `debounceManager.runWithDebounce`, and a subsequent call is made _updateSearchResults before that delay ends, we\n      // want to make sure that outstanding call to \"_updateSearchResults\" is cancelled, as it would apply state updates\n      // out of order.\n\n\n      _this.debounceManager.cancelByName(\"_updateSearchResults\");\n\n      _this._setState({\n        current: current,\n        error: \"\",\n        filters: filters,\n        resultsPerPage: resultsPerPage,\n        searchTerm: searchTerm,\n        sortDirection: sortDirection,\n        sortField: sortField\n      });\n\n      _this._makeSearchRequest({\n        skipPushToUrl: skipPushToUrl,\n        replaceUrl: replaceUrl\n      });\n    });\n\n    _defineProperty(this, \"_makeSearchRequest\", DebounceManager.debounce(0, function (_ref7) {\n      var skipPushToUrl = _ref7.skipPushToUrl,\n          replaceUrl = _ref7.replaceUrl;\n      var _this$state = _this.state,\n          current = _this$state.current,\n          filters = _this$state.filters,\n          resultsPerPage = _this$state.resultsPerPage,\n          searchTerm = _this$state.searchTerm,\n          sortDirection = _this$state.sortDirection,\n          sortField = _this$state.sortField;\n\n      _this._setState({\n        isLoading: true\n      });\n\n      var requestId = _this.searchRequestSequencer.next();\n\n      var queryConfig = _objectSpread({}, _this.searchQuery, {\n        facets: removeConditionalFacets(_this.searchQuery.facets, _this.searchQuery.conditionalFacets, filters)\n      });\n\n      var requestState = filterSearchParameters(_this.state);\n      return _this.events.search(requestState, queryConfig).then(function (resultState) {\n        if (_this.searchRequestSequencer.isOldRequest(requestId)) return;\n\n        _this.searchRequestSequencer.completed(requestId); // Results paging start & end\n\n\n        var totalResults = resultState.totalResults;\n        var start = totalResults === 0 ? 0 : (current - 1) * resultsPerPage + 1;\n        var end = totalResults <= start + resultsPerPage ? totalResults : start + resultsPerPage - 1;\n\n        _this._setState(_objectSpread({\n          isLoading: false,\n          resultSearchTerm: searchTerm,\n          pagingStart: start,\n          pagingEnd: end\n        }, resultState, {\n          wasSearched: true\n        }));\n\n        if (_this.hasA11yNotifications) {\n          var messageArgs = {\n            start: start,\n            end: end,\n            totalResults: totalResults,\n            searchTerm: searchTerm\n          };\n\n          _this.actions.a11yNotify(\"searchResults\", messageArgs);\n        }\n\n        if (!skipPushToUrl && _this.trackUrlState) {\n          // We debounce here so that we don't get a lot of intermediary\n          // URL state if someone is updating a UI really fast, like typing\n          // in a live search box for instance.\n          _this.debounceManager.runWithDebounce(_this.urlPushDebounceLength, \"pushStateToURL\", _this.URLManager.pushStateToURL.bind(_this.URLManager), {\n            current: current,\n            filters: filters,\n            resultsPerPage: resultsPerPage,\n            searchTerm: searchTerm,\n            sortDirection: sortDirection,\n            sortField: sortField\n          }, {\n            replaceUrl: replaceUrl\n          });\n        }\n      }, function (error) {\n        _this._setState({\n          error: \"An unexpected error occurred: \".concat(error.message)\n        });\n      });\n    }));\n\n    this.actions = Object.entries(actions).reduce(function (acc, _ref8) {\n      var _ref9 = _slicedToArray(_ref8, 2),\n          actionName = _ref9[0],\n          action = _ref9[1];\n\n      return _objectSpread({}, acc, _defineProperty({}, actionName, action.bind(_this)));\n    }, {});\n    Object.assign(this, this.actions);\n    this.events = new Events({\n      apiConnector: apiConnector,\n      onSearch: onSearch,\n      onAutocomplete: onAutocomplete,\n      onResultClick: onResultClick,\n      onAutocompleteResultClick: onAutocompleteResultClick\n    });\n    this.debug = debug;\n\n    if (this.debug) {\n      console.warn(\"Search UI Debugging is enabled. This should be turned off in production deployments.\");\n      window.searchUI = this;\n    }\n\n    this.autocompleteRequestSequencer = new RequestSequencer();\n    this.searchRequestSequencer = new RequestSequencer();\n    this.debounceManager = new DebounceManager();\n    this.autocompleteQuery = autocompleteQuery;\n    this.searchQuery = searchQuery;\n    this.subscriptions = [];\n    this.trackUrlState = trackUrlState;\n    this.urlPushDebounceLength = urlPushDebounceLength;\n    this.alwaysSearchOnInitialLoad = alwaysSearchOnInitialLoad;\n    var urlState;\n\n    if (trackUrlState) {\n      this.URLManager = new URLManager();\n      urlState = this.URLManager.getStateFromURL();\n      this.URLManager.onURLStateChange(function (urlState) {\n        _this._updateSearchResults(_objectSpread({}, DEFAULT_STATE, {}, urlState), {\n          skipPushToUrl: true\n        });\n      });\n    } else {\n      urlState = {};\n    } // Manage screen reader accessible notifications\n\n\n    this.hasA11yNotifications = hasA11yNotifications;\n    if (this.hasA11yNotifications) a11y.getLiveRegion();\n    this.a11yNotificationMessages = _objectSpread({}, a11y.defaultMessages, {}, a11yNotificationMessages); // Remember the state this application is initialized into, so that we can\n    // reset to it later.\n\n    this.startingState = _objectSpread({}, this.state, {}, initialState); // We filter these here to disallow anything other than valid search\n    // parameters to be passed in initial state, or url state. `results`, etc,\n    // should not be allowed to be passed in, that should be generated based on\n    // the results of the query\n\n    var _searchParameters = filterSearchParameters(_objectSpread({}, this.startingState, {}, urlState)); // Initialize the state without calling _setState, because we don't\n    // want to trigger an update callback, we're just initializing the state\n    // to the correct default values for the initial UI render\n\n\n    this.state = _objectSpread({}, this.state, {}, _searchParameters); // We'll trigger an initial search if initial parameters contain\n    // a search term or filters, or if alwaysSearchOnInitialLoad is set.\n    // Otherwise, we'll just save their selections in state as initial values.\n\n    if (_searchParameters.searchTerm || _searchParameters.filters.length > 0 || this.alwaysSearchOnInitialLoad) {\n      this._updateSearchResults(_searchParameters, {\n        replaceUrl: true\n      });\n    }\n  }\n  /**\n   * This method is used to update state and trigger a new autocomplete search.\n   *\n   * @param {string} searchTerm\n   * @param {Object=} Object\n   * @param {boolean|Object} options.autocompleteResults - Should autocomplete results\n   * @param {boolean|Object} options.autocompleteSuggestions - Should autocomplete suggestions\n   */\n\n\n  _createClass(SearchDriver, [{\n    key: \"_setState\",\n    value: function _setState(newState) {\n      var state = _objectSpread({}, this.state, {}, newState); // eslint-disable-next-line no-console\n\n\n      if (this.debug) console.log(\"Search UI: State Update\", newState, state);\n      this.state = state;\n      this.subscriptions.forEach(function (subscription) {\n        return subscription(state);\n      });\n    }\n    /**\n     * Any time state is updated in this Driver, the provided callback\n     * will be executed with the updated state.\n     *\n     * @param onStateChange Function\n     */\n\n  }, {\n    key: \"subscribeToStateChanges\",\n    value: function subscribeToStateChanges(onStateChange) {\n      this.subscriptions.push(onStateChange);\n    }\n    /**\n     * @param onStateChange Function\n     */\n\n  }, {\n    key: \"unsubscribeToStateChanges\",\n    value: function unsubscribeToStateChanges(onStateChange) {\n      this.subscriptions = this.subscriptions.filter(function (sub) {\n        return sub !== onStateChange;\n      });\n    }\n    /**\n     * Remove all listeners\n     */\n\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.subscriptions = [];\n      this.URLManager && this.URLManager.tearDown();\n    }\n    /**\n     * Retrieves all available acitons\n     *\n     * @returns Object All actions\n     */\n\n  }, {\n    key: \"getActions\",\n    value: function getActions() {\n      return this.actions;\n    }\n    /**\n     * Retrieve current state. Typically used on app initialization. Subsequent\n     * state updates should come through subscription.\n     *\n     * @returns Object Current state\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      // We return a copy of state here, because we want to ensure the state\n      // inside of this object remains immutable.\n      return _objectSpread({}, this.state);\n    }\n  }]);\n\n  return SearchDriver;\n}();\n\nexport { SearchDriver as default };","map":null,"metadata":{},"sourceType":"module"}