"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFilterValues = findFilterValues;
exports.removeSingleFilterValue = removeSingleFilterValue;
exports.markSelectedFacetValuesFromFilters = markSelectedFacetValuesFromFilters;
exports.doFilterValuesMatch = doFilterValuesMatch;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _deepEqual = _interopRequireDefault(require("deep-equal"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Given a list of applied Filters, find FilterValues based on
 * "fieldName" and "filterType".
 *
 * @param {*} filters
 * @param {*} name
 * @param {*} filterType
 */
function findFilterValues(filters, name, filterType) {
  var filter = filters.find(function (f) {
    return f.field === name && f.type === filterType;
  });
  if (!filter) return [];
  return filter.values;
}
/**
 * Given a list of applied Filters, remove a single FilterValue based on
 * "fieldName" and "filterType".
 *
 * @param {Filter[]} filters
 * @param {String} fieldName
 * @param {FilterValue} value
 * @param {FilterType} filterType
 */


function removeSingleFilterValue(filters, fieldName, value, filterType) {
  return filters.reduce(function (acc, filter) {
    var field = filter.field,
        values = filter.values,
        type = filter.type,
        rest = (0, _objectWithoutProperties2.default)(filter, ["field", "values", "type"]);

    if (field === fieldName && (!filterType || type === filterType)) {
      var updatedFilterValues = values.filter(function (filterValue) {
        return !doFilterValuesMatch(filterValue, value);
      });

      if (updatedFilterValues.length > 0) {
        return acc.concat(_objectSpread({
          field: field,
          values: updatedFilterValues,
          type: type
        }, rest));
      } else {
        return acc;
      }
    }

    return acc.concat(filter);
  }, []);
}
/**
 * Given a Facet and a list of applied Filters, mark the Facet Values
 * for that Facet as "selected" based on "fieldName" and "filterType".
 *
 * @param {Facet} facet
 * @param {String} fieldName
 * @param {Filter[]} filters
 * @param {FilterType} filterType
 */


function markSelectedFacetValuesFromFilters(facet, filters, fieldName, filterType) {
  var facetValues = facet.data;
  var filterValuesForField = findFilterValues(filters, fieldName, filterType) || [];
  return _objectSpread({}, facet, {
    data: facetValues.map(function (facetValue) {
      return _objectSpread({}, facetValue, {
        selected: filterValuesForField.some(function (filterValue) {
          return doFilterValuesMatch(filterValue, facetValue.value);
        })
      });
    })
  });
}
/**
 * Useful for determining when filter values match. This could be used
 * when matching applied filters back to facet options, or for determining
 * whether or not a filter already exists in a list of applied filters.
 *
 * @param {FilterValue} filterValue1
 * @param {FilterValue} filterValue2
 */


function doFilterValuesMatch(filterValue1, filterValue2) {
  if (filterValue1 && filterValue1.name && filterValue2 && filterValue2.name && filterValue1.name === filterValue2.name) // If two filters have matching names, then they are the same filter, there
    // is no need to do a more expensive deep equal comparison.
    //
    // This is also important because certain filters and facets will have
    // differing values than their corresponding facet options. For instance,
    // consider a time-based facet like "Last 10 Minutes". The value of the
    // filter will be different depending on when it was selected, but the name
    // will always match.
    return true; // We use 'strict = true' to do a '===' of leaves, rather than '=='

  return (0, _deepEqual.default)(filterValue1, filterValue2, {
    strict: true
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxwZXJzLmpzIl0sIm5hbWVzIjpbImZpbmRGaWx0ZXJWYWx1ZXMiLCJmaWx0ZXJzIiwibmFtZSIsImZpbHRlclR5cGUiLCJmaWx0ZXIiLCJmaW5kIiwiZiIsImZpZWxkIiwidHlwZSIsInZhbHVlcyIsInJlbW92ZVNpbmdsZUZpbHRlclZhbHVlIiwiZmllbGROYW1lIiwidmFsdWUiLCJyZWR1Y2UiLCJhY2MiLCJyZXN0IiwidXBkYXRlZEZpbHRlclZhbHVlcyIsImZpbHRlclZhbHVlIiwiZG9GaWx0ZXJWYWx1ZXNNYXRjaCIsImxlbmd0aCIsImNvbmNhdCIsIm1hcmtTZWxlY3RlZEZhY2V0VmFsdWVzRnJvbUZpbHRlcnMiLCJmYWNldCIsImZhY2V0VmFsdWVzIiwiZGF0YSIsImZpbHRlclZhbHVlc0ZvckZpZWxkIiwibWFwIiwiZmFjZXRWYWx1ZSIsInNlbGVjdGVkIiwic29tZSIsImZpbHRlclZhbHVlMSIsImZpbHRlclZhbHVlMiIsInN0cmljdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFFQTs7Ozs7Ozs7QUFRTyxTQUFTQSxnQkFBVCxDQUEwQkMsT0FBMUIsRUFBbUNDLElBQW5DLEVBQXlDQyxVQUF6QyxFQUFxRDtBQUMxRCxNQUFNQyxNQUFNLEdBQUdILE9BQU8sQ0FBQ0ksSUFBUixDQUFhLFVBQUFDLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUNDLEtBQUYsS0FBWUwsSUFBWixJQUFvQkksQ0FBQyxDQUFDRSxJQUFGLEtBQVdMLFVBQW5DO0FBQUEsR0FBZCxDQUFmO0FBQ0EsTUFBSSxDQUFDQyxNQUFMLEVBQWEsT0FBTyxFQUFQO0FBQ2IsU0FBT0EsTUFBTSxDQUFDSyxNQUFkO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7QUFTTyxTQUFTQyx1QkFBVCxDQUFpQ1QsT0FBakMsRUFBMENVLFNBQTFDLEVBQXFEQyxLQUFyRCxFQUE0RFQsVUFBNUQsRUFBd0U7QUFDN0UsU0FBT0YsT0FBTyxDQUFDWSxNQUFSLENBQWUsVUFBQ0MsR0FBRCxFQUFNVixNQUFOLEVBQWlCO0FBQUEsUUFDN0JHLEtBRDZCLEdBQ0lILE1BREosQ0FDN0JHLEtBRDZCO0FBQUEsUUFDdEJFLE1BRHNCLEdBQ0lMLE1BREosQ0FDdEJLLE1BRHNCO0FBQUEsUUFDZEQsSUFEYyxHQUNJSixNQURKLENBQ2RJLElBRGM7QUFBQSxRQUNMTyxJQURLLDBDQUNJWCxNQURKOztBQUVyQyxRQUFJRyxLQUFLLEtBQUtJLFNBQVYsS0FBd0IsQ0FBQ1IsVUFBRCxJQUFlSyxJQUFJLEtBQUtMLFVBQWhELENBQUosRUFBaUU7QUFDL0QsVUFBTWEsbUJBQW1CLEdBQUdQLE1BQU0sQ0FBQ0wsTUFBUCxDQUMxQixVQUFBYSxXQUFXO0FBQUEsZUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0QsV0FBRCxFQUFjTCxLQUFkLENBQXhCO0FBQUEsT0FEZSxDQUE1Qjs7QUFHQSxVQUFJSSxtQkFBbUIsQ0FBQ0csTUFBcEIsR0FBNkIsQ0FBakMsRUFBb0M7QUFDbEMsZUFBT0wsR0FBRyxDQUFDTSxNQUFKO0FBQ0xiLFVBQUFBLEtBQUssRUFBTEEsS0FESztBQUVMRSxVQUFBQSxNQUFNLEVBQUVPLG1CQUZIO0FBR0xSLFVBQUFBLElBQUksRUFBSkE7QUFISyxXQUlGTyxJQUpFLEVBQVA7QUFNRCxPQVBELE1BT087QUFDTCxlQUFPRCxHQUFQO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPQSxHQUFHLENBQUNNLE1BQUosQ0FBV2hCLE1BQVgsQ0FBUDtBQUNELEdBbEJNLEVBa0JKLEVBbEJJLENBQVA7QUFtQkQ7QUFFRDs7Ozs7Ozs7Ozs7QUFTTyxTQUFTaUIsa0NBQVQsQ0FDTEMsS0FESyxFQUVMckIsT0FGSyxFQUdMVSxTQUhLLEVBSUxSLFVBSkssRUFLTDtBQUNBLE1BQU1vQixXQUFXLEdBQUdELEtBQUssQ0FBQ0UsSUFBMUI7QUFDQSxNQUFNQyxvQkFBb0IsR0FDeEJ6QixnQkFBZ0IsQ0FBQ0MsT0FBRCxFQUFVVSxTQUFWLEVBQXFCUixVQUFyQixDQUFoQixJQUFvRCxFQUR0RDtBQUVBLDJCQUNLbUIsS0FETDtBQUVFRSxJQUFBQSxJQUFJLEVBQUVELFdBQVcsQ0FBQ0csR0FBWixDQUFnQixVQUFBQyxVQUFVLEVBQUk7QUFDbEMsK0JBQ0tBLFVBREw7QUFFRUMsUUFBQUEsUUFBUSxFQUFFSCxvQkFBb0IsQ0FBQ0ksSUFBckIsQ0FBMEIsVUFBQVosV0FBVyxFQUFJO0FBQ2pELGlCQUFPQyxtQkFBbUIsQ0FBQ0QsV0FBRCxFQUFjVSxVQUFVLENBQUNmLEtBQXpCLENBQTFCO0FBQ0QsU0FGUztBQUZaO0FBTUQsS0FQSztBQUZSO0FBV0Q7QUFFRDs7Ozs7Ozs7OztBQVFPLFNBQVNNLG1CQUFULENBQTZCWSxZQUE3QixFQUEyQ0MsWUFBM0MsRUFBeUQ7QUFDOUQsTUFDRUQsWUFBWSxJQUNaQSxZQUFZLENBQUM1QixJQURiLElBRUE2QixZQUZBLElBR0FBLFlBQVksQ0FBQzdCLElBSGIsSUFJQTRCLFlBQVksQ0FBQzVCLElBQWIsS0FBc0I2QixZQUFZLENBQUM3QixJQUxyQyxFQU9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPLElBQVAsQ0FoQjRELENBaUI5RDs7QUFDQSxTQUFPLHdCQUFVNEIsWUFBVixFQUF3QkMsWUFBeEIsRUFBc0M7QUFBRUMsSUFBQUEsTUFBTSxFQUFFO0FBQVYsR0FBdEMsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZXBFcXVhbCBmcm9tIFwiZGVlcC1lcXVhbFwiO1xuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBhcHBsaWVkIEZpbHRlcnMsIGZpbmQgRmlsdGVyVmFsdWVzIGJhc2VkIG9uXG4gKiBcImZpZWxkTmFtZVwiIGFuZCBcImZpbHRlclR5cGVcIi5cbiAqXG4gKiBAcGFyYW0geyp9IGZpbHRlcnNcbiAqIEBwYXJhbSB7Kn0gbmFtZVxuICogQHBhcmFtIHsqfSBmaWx0ZXJUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlsdGVyVmFsdWVzKGZpbHRlcnMsIG5hbWUsIGZpbHRlclR5cGUpIHtcbiAgY29uc3QgZmlsdGVyID0gZmlsdGVycy5maW5kKGYgPT4gZi5maWVsZCA9PT0gbmFtZSAmJiBmLnR5cGUgPT09IGZpbHRlclR5cGUpO1xuICBpZiAoIWZpbHRlcikgcmV0dXJuIFtdO1xuICByZXR1cm4gZmlsdGVyLnZhbHVlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgYXBwbGllZCBGaWx0ZXJzLCByZW1vdmUgYSBzaW5nbGUgRmlsdGVyVmFsdWUgYmFzZWQgb25cbiAqIFwiZmllbGROYW1lXCIgYW5kIFwiZmlsdGVyVHlwZVwiLlxuICpcbiAqIEBwYXJhbSB7RmlsdGVyW119IGZpbHRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWVcbiAqIEBwYXJhbSB7RmlsdGVyVmFsdWV9IHZhbHVlXG4gKiBAcGFyYW0ge0ZpbHRlclR5cGV9IGZpbHRlclR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVNpbmdsZUZpbHRlclZhbHVlKGZpbHRlcnMsIGZpZWxkTmFtZSwgdmFsdWUsIGZpbHRlclR5cGUpIHtcbiAgcmV0dXJuIGZpbHRlcnMucmVkdWNlKChhY2MsIGZpbHRlcikgPT4ge1xuICAgIGNvbnN0IHsgZmllbGQsIHZhbHVlcywgdHlwZSwgLi4ucmVzdCB9ID0gZmlsdGVyO1xuICAgIGlmIChmaWVsZCA9PT0gZmllbGROYW1lICYmICghZmlsdGVyVHlwZSB8fCB0eXBlID09PSBmaWx0ZXJUeXBlKSkge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbHRlclZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoXG4gICAgICAgIGZpbHRlclZhbHVlID0+ICFkb0ZpbHRlclZhbHVlc01hdGNoKGZpbHRlclZhbHVlLCB2YWx1ZSlcbiAgICAgICk7XG4gICAgICBpZiAodXBkYXRlZEZpbHRlclZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KHtcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICB2YWx1ZXM6IHVwZGF0ZWRGaWx0ZXJWYWx1ZXMsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZmlsdGVyKTtcbiAgfSwgW10pO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRmFjZXQgYW5kIGEgbGlzdCBvZiBhcHBsaWVkIEZpbHRlcnMsIG1hcmsgdGhlIEZhY2V0IFZhbHVlc1xuICogZm9yIHRoYXQgRmFjZXQgYXMgXCJzZWxlY3RlZFwiIGJhc2VkIG9uIFwiZmllbGROYW1lXCIgYW5kIFwiZmlsdGVyVHlwZVwiLlxuICpcbiAqIEBwYXJhbSB7RmFjZXR9IGZhY2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gKiBAcGFyYW0ge0ZpbHRlcltdfSBmaWx0ZXJzXG4gKiBAcGFyYW0ge0ZpbHRlclR5cGV9IGZpbHRlclR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtTZWxlY3RlZEZhY2V0VmFsdWVzRnJvbUZpbHRlcnMoXG4gIGZhY2V0LFxuICBmaWx0ZXJzLFxuICBmaWVsZE5hbWUsXG4gIGZpbHRlclR5cGVcbikge1xuICBjb25zdCBmYWNldFZhbHVlcyA9IGZhY2V0LmRhdGE7XG4gIGNvbnN0IGZpbHRlclZhbHVlc0ZvckZpZWxkID1cbiAgICBmaW5kRmlsdGVyVmFsdWVzKGZpbHRlcnMsIGZpZWxkTmFtZSwgZmlsdGVyVHlwZSkgfHwgW107XG4gIHJldHVybiB7XG4gICAgLi4uZmFjZXQsXG4gICAgZGF0YTogZmFjZXRWYWx1ZXMubWFwKGZhY2V0VmFsdWUgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmFjZXRWYWx1ZSxcbiAgICAgICAgc2VsZWN0ZWQ6IGZpbHRlclZhbHVlc0ZvckZpZWxkLnNvbWUoZmlsdGVyVmFsdWUgPT4ge1xuICAgICAgICAgIHJldHVybiBkb0ZpbHRlclZhbHVlc01hdGNoKGZpbHRlclZhbHVlLCBmYWNldFZhbHVlLnZhbHVlKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoZW4gZmlsdGVyIHZhbHVlcyBtYXRjaC4gVGhpcyBjb3VsZCBiZSB1c2VkXG4gKiB3aGVuIG1hdGNoaW5nIGFwcGxpZWQgZmlsdGVycyBiYWNrIHRvIGZhY2V0IG9wdGlvbnMsIG9yIGZvciBkZXRlcm1pbmluZ1xuICogd2hldGhlciBvciBub3QgYSBmaWx0ZXIgYWxyZWFkeSBleGlzdHMgaW4gYSBsaXN0IG9mIGFwcGxpZWQgZmlsdGVycy5cbiAqXG4gKiBAcGFyYW0ge0ZpbHRlclZhbHVlfSBmaWx0ZXJWYWx1ZTFcbiAqIEBwYXJhbSB7RmlsdGVyVmFsdWV9IGZpbHRlclZhbHVlMlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG9GaWx0ZXJWYWx1ZXNNYXRjaChmaWx0ZXJWYWx1ZTEsIGZpbHRlclZhbHVlMikge1xuICBpZiAoXG4gICAgZmlsdGVyVmFsdWUxICYmXG4gICAgZmlsdGVyVmFsdWUxLm5hbWUgJiZcbiAgICBmaWx0ZXJWYWx1ZTIgJiZcbiAgICBmaWx0ZXJWYWx1ZTIubmFtZSAmJlxuICAgIGZpbHRlclZhbHVlMS5uYW1lID09PSBmaWx0ZXJWYWx1ZTIubmFtZVxuICApXG4gICAgLy8gSWYgdHdvIGZpbHRlcnMgaGF2ZSBtYXRjaGluZyBuYW1lcywgdGhlbiB0aGV5IGFyZSB0aGUgc2FtZSBmaWx0ZXIsIHRoZXJlXG4gICAgLy8gaXMgbm8gbmVlZCB0byBkbyBhIG1vcmUgZXhwZW5zaXZlIGRlZXAgZXF1YWwgY29tcGFyaXNvbi5cbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgYWxzbyBpbXBvcnRhbnQgYmVjYXVzZSBjZXJ0YWluIGZpbHRlcnMgYW5kIGZhY2V0cyB3aWxsIGhhdmVcbiAgICAvLyBkaWZmZXJpbmcgdmFsdWVzIHRoYW4gdGhlaXIgY29ycmVzcG9uZGluZyBmYWNldCBvcHRpb25zLiBGb3IgaW5zdGFuY2UsXG4gICAgLy8gY29uc2lkZXIgYSB0aW1lLWJhc2VkIGZhY2V0IGxpa2UgXCJMYXN0IDEwIE1pbnV0ZXNcIi4gVGhlIHZhbHVlIG9mIHRoZVxuICAgIC8vIGZpbHRlciB3aWxsIGJlIGRpZmZlcmVudCBkZXBlbmRpbmcgb24gd2hlbiBpdCB3YXMgc2VsZWN0ZWQsIGJ1dCB0aGUgbmFtZVxuICAgIC8vIHdpbGwgYWx3YXlzIG1hdGNoLlxuICAgIHJldHVybiB0cnVlO1xuICAvLyBXZSB1c2UgJ3N0cmljdCA9IHRydWUnIHRvIGRvIGEgJz09PScgb2YgbGVhdmVzLCByYXRoZXIgdGhhbiAnPT0nXG4gIHJldHVybiBkZWVwRXF1YWwoZmlsdGVyVmFsdWUxLCBmaWx0ZXJWYWx1ZTIsIHsgc3RyaWN0OiB0cnVlIH0pO1xufVxuIl19