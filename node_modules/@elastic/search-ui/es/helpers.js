import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import deepEqual from "deep-equal";
/**
 * Given a list of applied Filters, find FilterValues based on
 * "fieldName" and "filterType".
 *
 * @param {*} filters
 * @param {*} name
 * @param {*} filterType
 */

export function findFilterValues(filters, name, filterType) {
  var filter = filters.find(function (f) {
    return f.field === name && f.type === filterType;
  });
  if (!filter) return [];
  return filter.values;
}
/**
 * Given a list of applied Filters, remove a single FilterValue based on
 * "fieldName" and "filterType".
 *
 * @param {Filter[]} filters
 * @param {String} fieldName
 * @param {FilterValue} value
 * @param {FilterType} filterType
 */

export function removeSingleFilterValue(filters, fieldName, value, filterType) {
  return filters.reduce(function (acc, filter) {
    var field = filter.field,
        values = filter.values,
        type = filter.type,
        rest = _objectWithoutProperties(filter, ["field", "values", "type"]);

    if (field === fieldName && (!filterType || type === filterType)) {
      var updatedFilterValues = values.filter(function (filterValue) {
        return !doFilterValuesMatch(filterValue, value);
      });

      if (updatedFilterValues.length > 0) {
        return acc.concat(_objectSpread({
          field: field,
          values: updatedFilterValues,
          type: type
        }, rest));
      } else {
        return acc;
      }
    }

    return acc.concat(filter);
  }, []);
}
/**
 * Given a Facet and a list of applied Filters, mark the Facet Values
 * for that Facet as "selected" based on "fieldName" and "filterType".
 *
 * @param {Facet} facet
 * @param {String} fieldName
 * @param {Filter[]} filters
 * @param {FilterType} filterType
 */

export function markSelectedFacetValuesFromFilters(facet, filters, fieldName, filterType) {
  var facetValues = facet.data;
  var filterValuesForField = findFilterValues(filters, fieldName, filterType) || [];
  return _objectSpread({}, facet, {
    data: facetValues.map(function (facetValue) {
      return _objectSpread({}, facetValue, {
        selected: filterValuesForField.some(function (filterValue) {
          return doFilterValuesMatch(filterValue, facetValue.value);
        })
      });
    })
  });
}
/**
 * Useful for determining when filter values match. This could be used
 * when matching applied filters back to facet options, or for determining
 * whether or not a filter already exists in a list of applied filters.
 *
 * @param {FilterValue} filterValue1
 * @param {FilterValue} filterValue2
 */

export function doFilterValuesMatch(filterValue1, filterValue2) {
  if (filterValue1 && filterValue1.name && filterValue2 && filterValue2.name && filterValue1.name === filterValue2.name) // If two filters have matching names, then they are the same filter, there
    // is no need to do a more expensive deep equal comparison.
    //
    // This is also important because certain filters and facets will have
    // differing values than their corresponding facet options. For instance,
    // consider a time-based facet like "Last 10 Minutes". The value of the
    // filter will be different depending on when it was selected, but the name
    // will always match.
    return true; // We use 'strict = true' to do a '===' of leaves, rather than '=='

  return deepEqual(filterValue1, filterValue2, {
    strict: true
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxwZXJzLmpzIl0sIm5hbWVzIjpbImRlZXBFcXVhbCIsImZpbmRGaWx0ZXJWYWx1ZXMiLCJmaWx0ZXJzIiwibmFtZSIsImZpbHRlclR5cGUiLCJmaWx0ZXIiLCJmaW5kIiwiZiIsImZpZWxkIiwidHlwZSIsInZhbHVlcyIsInJlbW92ZVNpbmdsZUZpbHRlclZhbHVlIiwiZmllbGROYW1lIiwidmFsdWUiLCJyZWR1Y2UiLCJhY2MiLCJyZXN0IiwidXBkYXRlZEZpbHRlclZhbHVlcyIsImZpbHRlclZhbHVlIiwiZG9GaWx0ZXJWYWx1ZXNNYXRjaCIsImxlbmd0aCIsImNvbmNhdCIsIm1hcmtTZWxlY3RlZEZhY2V0VmFsdWVzRnJvbUZpbHRlcnMiLCJmYWNldCIsImZhY2V0VmFsdWVzIiwiZGF0YSIsImZpbHRlclZhbHVlc0ZvckZpZWxkIiwibWFwIiwiZmFjZXRWYWx1ZSIsInNlbGVjdGVkIiwic29tZSIsImZpbHRlclZhbHVlMSIsImZpbHRlclZhbHVlMiIsInN0cmljdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLE9BQU9BLFNBQVAsTUFBc0IsWUFBdEI7QUFFQTs7Ozs7Ozs7O0FBUUEsT0FBTyxTQUFTQyxnQkFBVCxDQUEwQkMsT0FBMUIsRUFBbUNDLElBQW5DLEVBQXlDQyxVQUF6QyxFQUFxRDtBQUMxRCxNQUFNQyxNQUFNLEdBQUdILE9BQU8sQ0FBQ0ksSUFBUixDQUFhLFVBQUFDLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUNDLEtBQUYsS0FBWUwsSUFBWixJQUFvQkksQ0FBQyxDQUFDRSxJQUFGLEtBQVdMLFVBQW5DO0FBQUEsR0FBZCxDQUFmO0FBQ0EsTUFBSSxDQUFDQyxNQUFMLEVBQWEsT0FBTyxFQUFQO0FBQ2IsU0FBT0EsTUFBTSxDQUFDSyxNQUFkO0FBQ0Q7QUFFRDs7Ozs7Ozs7OztBQVNBLE9BQU8sU0FBU0MsdUJBQVQsQ0FBaUNULE9BQWpDLEVBQTBDVSxTQUExQyxFQUFxREMsS0FBckQsRUFBNERULFVBQTVELEVBQXdFO0FBQzdFLFNBQU9GLE9BQU8sQ0FBQ1ksTUFBUixDQUFlLFVBQUNDLEdBQUQsRUFBTVYsTUFBTixFQUFpQjtBQUFBLFFBQzdCRyxLQUQ2QixHQUNJSCxNQURKLENBQzdCRyxLQUQ2QjtBQUFBLFFBQ3RCRSxNQURzQixHQUNJTCxNQURKLENBQ3RCSyxNQURzQjtBQUFBLFFBQ2RELElBRGMsR0FDSUosTUFESixDQUNkSSxJQURjO0FBQUEsUUFDTE8sSUFESyw0QkFDSVgsTUFESjs7QUFFckMsUUFBSUcsS0FBSyxLQUFLSSxTQUFWLEtBQXdCLENBQUNSLFVBQUQsSUFBZUssSUFBSSxLQUFLTCxVQUFoRCxDQUFKLEVBQWlFO0FBQy9ELFVBQU1hLG1CQUFtQixHQUFHUCxNQUFNLENBQUNMLE1BQVAsQ0FDMUIsVUFBQWEsV0FBVztBQUFBLGVBQUksQ0FBQ0MsbUJBQW1CLENBQUNELFdBQUQsRUFBY0wsS0FBZCxDQUF4QjtBQUFBLE9BRGUsQ0FBNUI7O0FBR0EsVUFBSUksbUJBQW1CLENBQUNHLE1BQXBCLEdBQTZCLENBQWpDLEVBQW9DO0FBQ2xDLGVBQU9MLEdBQUcsQ0FBQ00sTUFBSjtBQUNMYixVQUFBQSxLQUFLLEVBQUxBLEtBREs7QUFFTEUsVUFBQUEsTUFBTSxFQUFFTyxtQkFGSDtBQUdMUixVQUFBQSxJQUFJLEVBQUpBO0FBSEssV0FJRk8sSUFKRSxFQUFQO0FBTUQsT0FQRCxNQU9PO0FBQ0wsZUFBT0QsR0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT0EsR0FBRyxDQUFDTSxNQUFKLENBQVdoQixNQUFYLENBQVA7QUFDRCxHQWxCTSxFQWtCSixFQWxCSSxDQUFQO0FBbUJEO0FBRUQ7Ozs7Ozs7Ozs7QUFTQSxPQUFPLFNBQVNpQixrQ0FBVCxDQUNMQyxLQURLLEVBRUxyQixPQUZLLEVBR0xVLFNBSEssRUFJTFIsVUFKSyxFQUtMO0FBQ0EsTUFBTW9CLFdBQVcsR0FBR0QsS0FBSyxDQUFDRSxJQUExQjtBQUNBLE1BQU1DLG9CQUFvQixHQUN4QnpCLGdCQUFnQixDQUFDQyxPQUFELEVBQVVVLFNBQVYsRUFBcUJSLFVBQXJCLENBQWhCLElBQW9ELEVBRHREO0FBRUEsMkJBQ0ttQixLQURMO0FBRUVFLElBQUFBLElBQUksRUFBRUQsV0FBVyxDQUFDRyxHQUFaLENBQWdCLFVBQUFDLFVBQVUsRUFBSTtBQUNsQywrQkFDS0EsVUFETDtBQUVFQyxRQUFBQSxRQUFRLEVBQUVILG9CQUFvQixDQUFDSSxJQUFyQixDQUEwQixVQUFBWixXQUFXLEVBQUk7QUFDakQsaUJBQU9DLG1CQUFtQixDQUFDRCxXQUFELEVBQWNVLFVBQVUsQ0FBQ2YsS0FBekIsQ0FBMUI7QUFDRCxTQUZTO0FBRlo7QUFNRCxLQVBLO0FBRlI7QUFXRDtBQUVEOzs7Ozs7Ozs7QUFRQSxPQUFPLFNBQVNNLG1CQUFULENBQTZCWSxZQUE3QixFQUEyQ0MsWUFBM0MsRUFBeUQ7QUFDOUQsTUFDRUQsWUFBWSxJQUNaQSxZQUFZLENBQUM1QixJQURiLElBRUE2QixZQUZBLElBR0FBLFlBQVksQ0FBQzdCLElBSGIsSUFJQTRCLFlBQVksQ0FBQzVCLElBQWIsS0FBc0I2QixZQUFZLENBQUM3QixJQUxyQyxFQU9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPLElBQVAsQ0FoQjRELENBaUI5RDs7QUFDQSxTQUFPSCxTQUFTLENBQUMrQixZQUFELEVBQWVDLFlBQWYsRUFBNkI7QUFBRUMsSUFBQUEsTUFBTSxFQUFFO0FBQVYsR0FBN0IsQ0FBaEI7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWVwRXF1YWwgZnJvbSBcImRlZXAtZXF1YWxcIjtcblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgYXBwbGllZCBGaWx0ZXJzLCBmaW5kIEZpbHRlclZhbHVlcyBiYXNlZCBvblxuICogXCJmaWVsZE5hbWVcIiBhbmQgXCJmaWx0ZXJUeXBlXCIuXG4gKlxuICogQHBhcmFtIHsqfSBmaWx0ZXJzXG4gKiBAcGFyYW0geyp9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gZmlsdGVyVHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpbHRlclZhbHVlcyhmaWx0ZXJzLCBuYW1lLCBmaWx0ZXJUeXBlKSB7XG4gIGNvbnN0IGZpbHRlciA9IGZpbHRlcnMuZmluZChmID0+IGYuZmllbGQgPT09IG5hbWUgJiYgZi50eXBlID09PSBmaWx0ZXJUeXBlKTtcbiAgaWYgKCFmaWx0ZXIpIHJldHVybiBbXTtcbiAgcmV0dXJuIGZpbHRlci52YWx1ZXM7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIGFwcGxpZWQgRmlsdGVycywgcmVtb3ZlIGEgc2luZ2xlIEZpbHRlclZhbHVlIGJhc2VkIG9uXG4gKiBcImZpZWxkTmFtZVwiIGFuZCBcImZpbHRlclR5cGVcIi5cbiAqXG4gKiBAcGFyYW0ge0ZpbHRlcltdfSBmaWx0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gKiBAcGFyYW0ge0ZpbHRlclZhbHVlfSB2YWx1ZVxuICogQHBhcmFtIHtGaWx0ZXJUeXBlfSBmaWx0ZXJUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVTaW5nbGVGaWx0ZXJWYWx1ZShmaWx0ZXJzLCBmaWVsZE5hbWUsIHZhbHVlLCBmaWx0ZXJUeXBlKSB7XG4gIHJldHVybiBmaWx0ZXJzLnJlZHVjZSgoYWNjLCBmaWx0ZXIpID0+IHtcbiAgICBjb25zdCB7IGZpZWxkLCB2YWx1ZXMsIHR5cGUsIC4uLnJlc3QgfSA9IGZpbHRlcjtcbiAgICBpZiAoZmllbGQgPT09IGZpZWxkTmFtZSAmJiAoIWZpbHRlclR5cGUgfHwgdHlwZSA9PT0gZmlsdGVyVHlwZSkpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWx0ZXJWYWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKFxuICAgICAgICBmaWx0ZXJWYWx1ZSA9PiAhZG9GaWx0ZXJWYWx1ZXNNYXRjaChmaWx0ZXJWYWx1ZSwgdmFsdWUpXG4gICAgICApO1xuICAgICAgaWYgKHVwZGF0ZWRGaWx0ZXJWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdCh7XG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgdmFsdWVzOiB1cGRhdGVkRmlsdGVyVmFsdWVzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgLi4ucmVzdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2MuY29uY2F0KGZpbHRlcik7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIEZhY2V0IGFuZCBhIGxpc3Qgb2YgYXBwbGllZCBGaWx0ZXJzLCBtYXJrIHRoZSBGYWNldCBWYWx1ZXNcbiAqIGZvciB0aGF0IEZhY2V0IGFzIFwic2VsZWN0ZWRcIiBiYXNlZCBvbiBcImZpZWxkTmFtZVwiIGFuZCBcImZpbHRlclR5cGVcIi5cbiAqXG4gKiBAcGFyYW0ge0ZhY2V0fSBmYWNldFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkTmFtZVxuICogQHBhcmFtIHtGaWx0ZXJbXX0gZmlsdGVyc1xuICogQHBhcmFtIHtGaWx0ZXJUeXBlfSBmaWx0ZXJUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrU2VsZWN0ZWRGYWNldFZhbHVlc0Zyb21GaWx0ZXJzKFxuICBmYWNldCxcbiAgZmlsdGVycyxcbiAgZmllbGROYW1lLFxuICBmaWx0ZXJUeXBlXG4pIHtcbiAgY29uc3QgZmFjZXRWYWx1ZXMgPSBmYWNldC5kYXRhO1xuICBjb25zdCBmaWx0ZXJWYWx1ZXNGb3JGaWVsZCA9XG4gICAgZmluZEZpbHRlclZhbHVlcyhmaWx0ZXJzLCBmaWVsZE5hbWUsIGZpbHRlclR5cGUpIHx8IFtdO1xuICByZXR1cm4ge1xuICAgIC4uLmZhY2V0LFxuICAgIGRhdGE6IGZhY2V0VmFsdWVzLm1hcChmYWNldFZhbHVlID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmZhY2V0VmFsdWUsXG4gICAgICAgIHNlbGVjdGVkOiBmaWx0ZXJWYWx1ZXNGb3JGaWVsZC5zb21lKGZpbHRlclZhbHVlID0+IHtcbiAgICAgICAgICByZXR1cm4gZG9GaWx0ZXJWYWx1ZXNNYXRjaChmaWx0ZXJWYWx1ZSwgZmFjZXRWYWx1ZS52YWx1ZSk7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG59XG5cbi8qKlxuICogVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGVuIGZpbHRlciB2YWx1ZXMgbWF0Y2guIFRoaXMgY291bGQgYmUgdXNlZFxuICogd2hlbiBtYXRjaGluZyBhcHBsaWVkIGZpbHRlcnMgYmFjayB0byBmYWNldCBvcHRpb25zLCBvciBmb3IgZGV0ZXJtaW5pbmdcbiAqIHdoZXRoZXIgb3Igbm90IGEgZmlsdGVyIGFscmVhZHkgZXhpc3RzIGluIGEgbGlzdCBvZiBhcHBsaWVkIGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIHtGaWx0ZXJWYWx1ZX0gZmlsdGVyVmFsdWUxXG4gKiBAcGFyYW0ge0ZpbHRlclZhbHVlfSBmaWx0ZXJWYWx1ZTJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvRmlsdGVyVmFsdWVzTWF0Y2goZmlsdGVyVmFsdWUxLCBmaWx0ZXJWYWx1ZTIpIHtcbiAgaWYgKFxuICAgIGZpbHRlclZhbHVlMSAmJlxuICAgIGZpbHRlclZhbHVlMS5uYW1lICYmXG4gICAgZmlsdGVyVmFsdWUyICYmXG4gICAgZmlsdGVyVmFsdWUyLm5hbWUgJiZcbiAgICBmaWx0ZXJWYWx1ZTEubmFtZSA9PT0gZmlsdGVyVmFsdWUyLm5hbWVcbiAgKVxuICAgIC8vIElmIHR3byBmaWx0ZXJzIGhhdmUgbWF0Y2hpbmcgbmFtZXMsIHRoZW4gdGhleSBhcmUgdGhlIHNhbWUgZmlsdGVyLCB0aGVyZVxuICAgIC8vIGlzIG5vIG5lZWQgdG8gZG8gYSBtb3JlIGV4cGVuc2l2ZSBkZWVwIGVxdWFsIGNvbXBhcmlzb24uXG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIGFsc28gaW1wb3J0YW50IGJlY2F1c2UgY2VydGFpbiBmaWx0ZXJzIGFuZCBmYWNldHMgd2lsbCBoYXZlXG4gICAgLy8gZGlmZmVyaW5nIHZhbHVlcyB0aGFuIHRoZWlyIGNvcnJlc3BvbmRpbmcgZmFjZXQgb3B0aW9ucy4gRm9yIGluc3RhbmNlLFxuICAgIC8vIGNvbnNpZGVyIGEgdGltZS1iYXNlZCBmYWNldCBsaWtlIFwiTGFzdCAxMCBNaW51dGVzXCIuIFRoZSB2YWx1ZSBvZiB0aGVcbiAgICAvLyBmaWx0ZXIgd2lsbCBiZSBkaWZmZXJlbnQgZGVwZW5kaW5nIG9uIHdoZW4gaXQgd2FzIHNlbGVjdGVkLCBidXQgdGhlIG5hbWVcbiAgICAvLyB3aWxsIGFsd2F5cyBtYXRjaC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgdXNlICdzdHJpY3QgPSB0cnVlJyB0byBkbyBhICc9PT0nIG9mIGxlYXZlcywgcmF0aGVyIHRoYW4gJz09J1xuICByZXR1cm4gZGVlcEVxdWFsKGZpbHRlclZhbHVlMSwgZmlsdGVyVmFsdWUyLCB7IHN0cmljdDogdHJ1ZSB9KTtcbn1cbiJdfQ==